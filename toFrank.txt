 //////////////////////// electron selection in EC////////////////////////////////////////////
                      // gpart bank  for electrons //

   for(int i= 0; i< TMath::Min(25, gpart); i++)
    { 
       bool flag = false;
    if( p[i]>0.7 && p[i]<6.0 &&
        id[i] ==11 && 
        stat[i]>0 //&& 
        ec_ei[ec[i]-1] >0.0 && ec_eo[ec[i]-1] >0.0  && 
        dc_stat[dc[i]-1]>0 && nphe[cc[i]-1] >0 
        ){

        // Do the vertez correction of Nathan
        vz[i] = EG6VertexCorrCLAS(RunNumber, vz[i], cx[i], cy[i], cz[i]);
        flag = true;      
        h_z_e->Fill(vz[i]);
       }

  if( flag == true) && -77.<vz[i] && vz[i]<-50.)
    {
     note 1: I need to see the # of electrons paased to here :: 1<<endl;
     initial_number_of_e++;
     float rr = sqrt(tl1_x[dc[i]-1]*tl1_x[dc[i]-1] +
                     tl1_y[dc[i]-1]*tl1_y[dc[i]-1] + 
                     pow((tl1_z[dc[i]-1]-vz[i]),2));
     float dc_theta = (TMath::ACos((tl1_z[dc[i]-1]-vz[i])/rr))*TODEG;
     float dc_phi = (TMath::ATan2(tl1_y[dc[i]-1], tl1_x[dc[i]-1])) *TODEG;
     float ec_theta=(TMath::ACos(cz[i]))*TODEG;
     float ec_phi= (TMath::ATan2 (cy[i],cx[i])) *TODEG;
     float ece = TMath::Max(ec_ei[ec[i]-1]+ec_eo[ec[i]-1], etot[ec[i]-1]);
     float ece_p;
     if ( 0.1 <EG6ECsampcorr(dc_sect[dc[i]-1], RunNumber, evntid)) 
         ece_p = (ece/p[i])* (0.31/EG6ECsampcorr(dc_sect[dc[i]-1], RunNumber, evntid)); 
      else ece_p = (ece/p[i]);


     ////////Set the EC_XYZ to EC_UVW  ---------------------------------
     EC_XYZ.SetXYZ(ech_x[ec[i]-1],ech_y[ec[i]-1],ech_z[ec[i]-1]);
     EC_UVW=EC_XYZ_UVW(EC_XYZ);
     float ec_u= EC_UVW(0);
     float ec_v= EC_UVW(1); 
     float ec_w= EC_UVW(2); 
       h_EC_el_U->Fill(ec_u);
       h_EC_el_V->Fill(ec_v);
       h_EC_el_W->Fill(ec_w);

     bool UVW_Fiducial_cut= false;
     if(60.0<ec_u && ec_u<350 && ec_v <370. && ec_w < 400.0) UVW_Fiducial_cut=true;

     ////////// FX backword method to find the shadow of ic on dc --------------
     // track position at L1 DC
     float Xi= tl1_x[dc[i]-1];
     float Yi= tl1_y[dc[i]-1];
     float Zi= tl1_z[dc[i]-1];
     // track direction (cosines) at L1 DC
     float cXi = tl1_cx[dc[i]-1];
     float cYi = tl1_cy[dc[i]-1];
     float cZi = tl1_cz[dc[i]-1];
     // extrapolate track to Z=+16
     TVector3 VI(Xi,Yi,Zi);
     TVector3 PI(cXi,cYi,cZi);
     e_ic_x= 0;
     e_ic_y= 0;
     e_s= 0;
     // get the shift on the track between the IC and the first region of DC         
     if(cZi>0 && Zi!=0) {
       TVector3 Shift= ((Zi-16)/cZi)*PI;
       e_ic_x= (float)(VI-Shift).X();
       e_ic_y= (float)(VI-Shift).Y();
       e_s= dc_sect[dc[i]-1];
       }          

      /////// DC fiducial cut  --------------------------------------
      bool DC_Fiducial_cut= false;
      DC_Fiducial_cut= DCff_e(e_ic_x, e_ic_y , e_s );

       h_e_1_nphe->Fill(nphe[cc[i]-1]);
       h_e_nphe_1[dc_sect[dc[i]-1]]->Fill(nphe[cc[i]-1]);
       h_e_phi_theta_1->Fill(dc_theta, dc_phi);

       ////////// CC coordinates fiducial cuts
       int nt;
       float point[3], dir[3], xx[3], dist, r, s;
       float cc_pln[3] = { - 0.0007840784063, 0., - 0.001681461571 }; //was static in Vlassov's code
       point[0] = dc_xsc[dc[i]-1];
       point[1] = dc_ysc[dc[i]-1];
       point[2] = dc_zsc[dc[i]-1];
       dir[0] = dc_cxsc[dc[i]-1];
       dir[1] = dc_cysc[dc[i]-1];
       dir[2] = dc_czsc[dc[i]-1];
       nt = basics_vcrpl(point, dir, cc_pln, &dist, xx);
          r= sqrt(xx[0]*xx[0] + xx[1]*xx[1] + xx[2]*xx[2]);
          s= sqrt(xx[0]*xx[0] + xx[1]*xx[1]);
          float CC_Th_e = TMath::RadToDeg()*TMath::ACos(xx[2]/r);
          float CC_Ph_e = TMath::RadToDeg()*TMath::ATan2(xx[1]/s,xx[0]/s);


       ////// CC fiducial cut --------------------------------
       bool CC_Fiducial_cut= false;
       if(nt){ if(CC_Fid(CC_Th_e,CC_Ph_e)) CC_Fiducial_cut= true;  }//found CC plane intersection

       /////// IC shadow on DC fiducial cut ------------------------
       bool IC_DC_Shadow_Fiducial_cut = false;
       IC_DC_Shadow_Fiducial_cut = IC_DC_shadow_fiducial (e_ic_x, e_ic_y);


       h_EC_XY_el_1->Fill(ech_x[ec[i]-1],ech_y[ec[i]-1]);
       //h_DC_el_1->Fill(e_ic_x, e_ic_y);
       h_CC_el_phi_theta_1->Fill(CC_Th_e, CC_Ph_e); 
       h_el_DC_IC_XY_1->Fill(e_ic_x, e_ic_y);

        if(UVW_Fiducial_cut==true)        h_EC_XY_el_2->Fill(ech_x[ec[i]-1],ech_y[ec[i]-1]);
        if( CC_Fiducial_cut == true)      h_CC_el_phi_theta_2->Fill(CC_Th_e, CC_Ph_e);
        if(IC_DC_Shadow_Fiducial_cut == true)          h_el_DC_IC_XY_2->Fill(e_ic_x, e_ic_y);
        if (DC_Fiducial_cut == true && IC_DC_Shadow_Fiducial_cut == true )  h_DC_el_1->Fill(e_ic_x, e_ic_y);
        if (DC_Fiducial_cut == false || IC_DC_Shadow_Fiducial_cut == false ) h_DC_el_2->Fill(e_ic_x, e_ic_y);

       /// uvw fiducial cut
       if(UVW_Fiducial_cut==true)
        {
         note 2: I need to see the # of electrons paased to here :: 2<<endl;
         float mean_ece_p = 2.56084e-01 +4.32374e-02*p[i] -9.14180e-03*pow(p[i],2) +8.15895e-04*pow(p[i],3);
         float sigma_p = 0.0572976 -0.0272689*p[i] +0.00857596*pow(p[i],2) -0.000979978*pow(p[i],3);

         h_e_phi_theta_2->Fill(dc_theta, dc_phi);

         //// CC fiducial cut + IC shadow on DC fiducial cut + the DC sectors cut
         if(CC_Fiducial_cut== true && IC_DC_Shadow_Fiducial_cut == true && DC_Fiducial_cut ==true)
          {
     note 3: I need to see the # of electrons paased to here :: 3<<endl;
           h_e_nphe_2[dc_sect[dc[i]-1]]->Fill(nphe[cc[i]-1]);
           h_e_2_nphe->Fill(nphe[cc[i]-1]);
           h_e_phi_theta_3->Fill(dc_theta, dc_phi);
           h_eco_eci->Fill(ec_ei[ec[i]-1], ec_eo[ec[i]-1]);
           h_etot_p->Fill(p[i], ece_p);
           

           if(abs(ece_p - mean_ece_p)> 2.5 * sigma_p) h_etot_p_2->Fill(p[i], ece_p);

           if(ec_ei[ec[i]-1]>0.06 && abs(ece_p - mean_ece_p)< 2.5 * sigma_p)
            {
     note 4: I need to see the # of electrons paased to here :: 4<<endl;
             h_e_3_nphe->Fill(nphe[cc[i]-1]);
             h_etot_p_3->Fill(p[i], ece_p);
             h_e_nphe_3[dc_sect[dc[i]-1]]->Fill(nphe[cc[i]-1]);              
             h_ece_over_p_nphe[dc_sect[dc[i]-1]]->Fill(nphe[cc[i]-1], ece_p);              
             h_ch2cc_nphe[dc_sect[dc[i]-1]]->Fill(nphe[cc[i]-1], cc_c2[cc[i]-1]);              

             if (nphe[cc[i]-1] >20 )
              {
     note 5: I need to see the # of electrons paased to here :: 5<<endl;
               Q2[n_e_ec] = 4*p[i]*Eb*pow(sin(ec_theta*TORAD/2), 2);
               nu[n_e_ec] = (Eb - p[i]);
               yy[n_e_ec] = nu[n_e_ec]/Eb;
               W_4He[n_e_ec]= sqrt(M_4He*M_4He + 2*M_4He*nu[n_e_ec] - Q2[n_e_ec]);
               W_p[n_e_ec]= sqrt(M_p*M_p + 2*M_p*nu[n_e_ec] - Q2[n_e_ec]);
               xB[n_e_ec]= Q2[n_e_ec]/(2*M_p*nu[n_e_ec]);

               h_e_phi_theta_4->Fill(dc_theta, dc_phi);                             
               h_nu->Fill(nu[n_e_ec]);
               h_Q2->Fill(Q2[n_e_ec]);
               h_W_4He->Fill(W_4He[n_e_ec]);
               h_W_p->Fill(W_p[n_e_ec]);
               h_xB->Fill(xB[n_e_ec]);
               h_yy->Fill(yy[n_e_ec]);
               h_Q2_xB->Fill(xB[n_e_ec], Q2[n_e_ec]);
              
               Elec4Vector[n_e_ec].SetPxPyPzE(p[i]*cx[i],p[i]*cy[i],p[i]*cz[i], p[i]);

	               El_Px[n_e_ec] = Elec4Vector[n_e_ec].Px();
        	       El_Py[n_e_ec] = Elec4Vector[n_e_ec].Py();
	               El_Pz[n_e_ec] = Elec4Vector[n_e_ec].Pz();
        	       El_P[n_e_ec] = Elec4Vector[n_e_ec].P();
	               El_E[n_e_ec] = Elec4Vector[n_e_ec].E();
        	       El_Phi[n_e_ec] = Elec4Vector[n_e_ec].Phi()*TODEG;
	               El_Theta[n_e_ec] = Elec4Vector[n_e_ec].Theta()*TODEG;
        	       El_z[n_e_ec] =vz[i];
	               El_s[n_e_ec] = dc_sect[dc[i]-1];
	               El_nphe[n_e_ec] = nphe[cc[i]-1];
               
               Iam_el= i;
               n_e_ec++;
               id_e_ec[n_e_ec - 1] = i;

               N_e_Run[runnb-61500] += 1.0;

             //  }
              }
             }
           }
          }
        } /////// end gpart bank for electrons from EC ------------------------------------------------------

